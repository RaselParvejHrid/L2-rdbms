# Discussion on 5 RDBMS(PostgresQL) Topics

এই আর্টিকেলে আমরা 5টি PostgresQL (বা, সাধারণভাবে, RDBMS) টপিক  নিয়ে আলোচনা করবো।

<h2 id="topics">টপিকসমূহ</h2>

1. <a href="#topic-1" style="text-decoration: none;">PostgresQL-এ Database Schema-এর উদ্দেশ্য কী?</a>
2. <a href="#topic-2" style="text-decoration: none;">PostgresQL-এ Primary Key ও Foreign Key-এর ধারণা ব্যাখ্যা করো।</a>
3. <a href="#topic-3" style="text-decoration: none;">PostgresQL-এ VARCHAR ও CHAR ডাটাটাইপের পার্থক্য কী?</a>
4. <a href="#topic-4" style="text-decoration: none;">PostgresQL-এ SELECT স্টেটমেন্টের সাথে WHERE ক্লজের উদ্দেশ্য কী?</a>
5. <a href="#topic-5" style="text-decoration: none;">PostgresQL-এ LIMIT ও OFFSET ক্লজগুলো কেন ব্যবহার করা হয়?</a>

<h2 id="topic-1">PostgresQL-এ Database Schema-এর উদ্দেশ্য কী?</h2>
<a href="#topics" style="text-decoration: none;">টপিকসমূহ</a>


একটি PostgresQL ডাটাবেস ক্লাস্টারে, বা ইনফর্মালি বললে, একটি PostgresQL ইন্সটলেশনে, এক বা একাধিক ডাটাবেস থাকে।

একইভাবে, একটি ডাটাবেসে এক বা একাধিক স্কিমা (Schema) থাকে। কেন?

একটি ডাটাবেসে বিভিন্ন রকম অবজেক্ট থাকতে পারে। যেমন— টেবিল, ভিউ, ইনডেক্স, ট্রিগার, ফাংশন ইত্যাদি। প্রতি ধরণের অবজেক্টের সংখ্যা অনেক হতে পারে। তখন এদের নামকরণের ক্ষেত্রে কলিশন দেখা দিতে পারে। একটা নতুন টেবিলের নাম দিতে গিয়ে দেখা যেতে পারে, একই নামে আগে থেকেই একটা টেবিল আছে। বা, একটা নতুন ইনডেক্সের নাম দিতে গিয়ে দেখা যেতে পারে যে, একই নামে একটা টেবিল আছে আগে থেকেই। ফলে, এই নামটা এই ইনডেক্সকে দেওয়া যাবে না।

প্রায়োগিক ক্ষেত্রে দেখা যায় যে, একটি ডাটাবেসে টেবিলসহ বিভিন্ন অবজেক্ট এমন সংখ্যায় থাকে যে, এই নামের সংঘর্ষ একটা ঝামেলা হয়ে দাঁড়ায়। তাই, ডাটাবেসের অধীনে এক বা একাধিক স্কিমার ব্যবস্থা আছে।

স্কিমা হলো নেমস্পেস সলুশন। একটি ডাটাবেসের অধীনে টেবিল, ভিউ, ইনডেক্স, ট্রিগার ও ফাংশনসহ সকল অবজেক্টকে এক বা একাধিক স্কিমার অধীনে ভাগ করা হয়। তখন এক স্কিমার কোনো একটা অবজেক্টের নামকে আরেক স্কিমার কোনো অবজেক্টের নাম হিসেবে রি-ইউজ করা যায়, কলিশন বা কনফিউশন ঘটে না। নাম সংঘর্ষের সম্ভাবনা কমে আসে।

ডাটাবেসের এই অবজেক্টগুলোকে নিছক এলোমেলো ইচ্ছামত ভাগ করা হয় না। অবজেক্টগুলোকে লজিক্যাল গ্রুপেই ভাগ করা হয়, যাতে সম্পর্কিত অবজেক্টগুলো একই স্কিমায় থাকে। এতে ডাটাবেস লজিক্যালি অর্গানাইজড থাকে। যেমন অথেনটিকেশনের টেবিলগুলো এক স্কিমায়, এনালাইটিকস-এর টেবিলগুলো আরেক স্কিমায় ইত্যাদি। এই লজিক্যাল অর্গানাইজেশনের কল্যাণে বৃদ্ধির সাথে সাথেও ডাটাবেস অনেক ম্যানেজেবল থাকে।

আবার, ভিন্ন ভিন্ন টিমকে বা থার্ড পার্টি টুল বা এ্যাপলিকেশনকে আলাদা স্কিমা দেওয়ার মাধ্যমে, একই ডাটাবেস স্পেস নেম-কলিশনের ভয় বাদেই একাধিক টিম বা এ্যাপের সাথে ইউজ করা যায়। একাধিক ডাটাবেস ক্রয় বা ম্যানেজ করা লাগলো না।

<h2 id="topic-2">PostgresQL-এ Primary Key ও Foreign Key-এর ধারণা ব্যাখ্যা করো।</h2>
<a href="#topics" style="text-decoration: none;">টপিকসমূহ</a>

রিলেশনাল ডাটাবেস ম্যানেজমেন্ট সিস্টেমে, ব্যবহারিক ক্ষেত্রে, একটি ডাটাবেসে এক বা একাধিক টেবিল (Table/Relation) থাকে।


একটি টেবিলের এমন এক বা একাধিক এট্রিবিউট, যার বা যাদের মান ঐ টেবিলের সারিগুলোকে (Row/Tuple) অদ্বিতীয়ভাবে চিহ্নিত বা শনাক্ত করতে পারে, এমন এক বা একাধিক এট্রিবিউটের সেটকে আমরা বলি ঐ টেবিলের একটি সুপার কী (Super Key)।

একটি সুপার কী-তে এক বা একাধিক অতিরিক্ত এট্রিবিউট থাকতে পারে, যেগুলো বাদেও সুপার কী-টি একটি সুপার কী হিসেবে বিবেচ্য হতে পারে।

অতিরিক্ত এট্রিবিউট নেই, এমন সুপার কী-কে ক্যান্ডিডেট কী (Candidate Key) বলে।

একটি ডাটাবেস তৈরির সময় ডাটাবেস ইঞ্জিনিয়ার একটি ক্যান্ডিডেট কী-কে প্রাইমারি কী হিসেবে বেছে নেন। ব্যবহারিক সুবিধার জন্য, প্রাইমারি কী সাধারণত কেবল একটি এট্রিবিউট দিয়ে গঠিত হয়।

যেমন— একটি সুপারশপের ডাটাবেসের sellsmen টেবিলে সুপারশপের সেলসম্যানদের তথ্য থাকতে পারে। ধরি, এই টেবিল বা রিলেশনের স্কিমা হলো sellsmen(sellsman_id, name, phone_number)। ডাটাবেস ইঞ্জিনিয়ার sellsman_id এট্রিবিউটকে এই রিলেশনের প্রাইমারি কী হিসেবে বেছে নিবেন। একজন সেলসম্যানের জন্য phone_number যদিও ইউনিক, এটা পরিবর্তনশীল। তাই, sellsman_id প্রাইমারি কী হিসেবে শ্রেয় চয়েজ।


sellsman_id প্রাইমারি কী মানে— কোনো সেলসম্যানের জন্যই, তথা এই টেবিলের কোনো সারি বা টাপলের জন্য, এই sellsman_id ফিল্ড null হবে না; প্রতি sellsman-এর জন্য এটা ইউনিক হবে। অর্থাৎ কোনো দুই সেলসম্যানের জন্য, বা sellsmen টেবিল বা রিলেশনের যেকোনো দুই সারির জন্য, এই sellman_id একই হবে না।

sellsman_id এই টেবিলের প্রতিটি রো-কে ইউনিকলি আইডেন্টিফাই করে।


এবার আমরা কথা বলবো, Foreign Key নিয়ে।

ধরি, সুপারশপে অর্ডারগুলো ট্র্যাক করার জন্য ডাটাবেসে আরেকটি টেবিল orders আছে। মাসশেষে সেলসম্যানদের পারফর্ম্যান্স মূল্যায়ন করতে, কোনো অর্ডার কোন সেলসম্যান গ্রহণ করেছে, তার ট্রাক রাখা জরুরি। এই টেবিলের স্কিমা orders(order_id, product_description, customer_phone_number, sellsman_id)।

খেয়াল করো, শেষ এট্রিবিউটটি কিন্তু sellsmen টেবিলের প্রাইমারি। একটি অর্ডার কে গ্রহণ করেছে, তা orders টেবিলে sellsman_id দিয়ে কোনো রকম দ্বিধা বাদে জানা যাবে। কারণ, sellsman_id এট্রিবিউটটি sellsman টেবিলে একটি সারিকে তথা একজন সেলসম্যানকে অদ্বিতীয়ভাবে চিহ্নিত করে।

orders টেবিলের প্রাইমারি কী হলো order_id। এই টেবিলে sellsman_id প্রাইমারি কী হওয়া তো বহুদুর, বরং ইউনিকও না। কারণ, একাধিক অর্ডার হতে পারে একই সেলসম্যান গ্রহণ করেছে। এই টেবিলে প্রাইমারি কী না হলেও, এই এট্রিবিউটটি কিন্তু sellsmen টেবিলে প্রাইমারি কী।

sellsman_id এট্রিবিউট অন্য এক টেবিলের প্রাইমারি কী, যা orders টেবিলে থেকে orders টেবিলের সাথে sellsmen টেবিলের সম্পর্ক স্থাপন করছে। কোন অর্ডার কোন সেলসম্যান গ্রহণ করেছে, সে সম্পর্ক। তাই, sellsman_id এট্রিবিউটটি orders টেবিলে Foreign কী, এবং sellsmen টেবিলে প্রাইমারি কী। 


<h2 id="topic-3">PostgresQL-এ VARCHAR ও CHAR ডাটাটাইপের পার্থক্য কী?</h2>
<a href="#topics" style="text-decoration: none;">টপিকসমূহ</a>


VARCHAR(n) হলো PostgresQL-এ একটি ডাটাটাইপ।

যেমন— VARCHAR(10) হলো এমন একটি ডাটাটাইপ, যে টাইপ কোনো টেবিল এট্রিবিউট বা কলামকে দেওয়া হলে, ঐ কলামে অনুর্ধ্ব 10 ক্যারাক্টারের স্ট্রিং রাখা যাবে।

'Hi' রাখা যাবে, 'Hi' হিসেবেই থাকবে। 'Hello' রাখা যাবে, 'Hello' হিসেবে থাকবে। কিন্তু এমন কোনো স্ট্রিং রাখা যাবে না, যেটাতে ক্যারাক্টার 10টির বেশি।

অতএব, VARCHAR একটি ভ্যারিয়েবল লেংথ ডাটাটাইপ, যা ডিক্লেয়ারের সময় সর্বোচ্চ লেংথ ঠিক করে দেওয়া যায়, যে সর্বোচ্চ লেংথ অবশ্য পরে আবার চাইলে উপযুক্ত পরিস্থিতিতে পরিবর্তন করা যায়।

অন্যদিকে, CHAR(n) হলো ফিক্সড লেংথ ডাটাটাইপ।

 যেমন— CHAR(10) হলো এমন একটি ডাটাটাইপ, যে টাইপ কোনো টেবিল এট্রিবিউট বা কলামকে দেওয়া হলে, ঐ কলামে ঠিক 10 ক্যারাক্টারের স্ট্রিং রাখা যাবে।

'Hello' রাখা যাবে, কিন্তু 'Hello' হিসেবে থাকবে না। বরং, এই স্ট্রিং-এর লেংথ 10-এর চেয়ে ছোট বলে, PostgresQL নিজে স্ট্রিং-এর পিছনে আরো পাঁচটি স্পেস ক্যারাক্টার প্যাড করে, স্ত্রিংটিকে 10 ক্যারাক্টারের বানিয়ে, 'Hello_____' (Underscore-এর জায়গায় আসলে স্পেস) হিসেবে রাখবে। রিট্রিভের সময় 'Hello' দিবে না; বরং 5টি স্পেসসহ 'Hello_____' দিবে।

তবে হ্যাঁ, VARCHAR(10)-এর মত CHAR(10)-এও 10 ক্যারাক্টারের বেশি লম্বা স্ট্রিং রাখা যাবে না।


ব্যবহারিক ক্ষেত্রে, CHAR-এর প্রয়োজন খুবই কম। VARCHAR তুলনামূলক মেমোরি-এফিশিয়েন্ট। তাই, ফিক্সড-লেংথ স্ট্রিং-এর প্রয়োজন থাকলেও সেটার জন্য ডাটাবেসে CHAR ব্যবহার না করে, ডাটাবেসে VARCHAR ব্যবহার করে, ফিক্সড লেংথ-এর যে প্রয়োজন, সেটা ডাটাবেসে লেয়ারে না চাপিয়ে এপলিকেশন লেয়ারে মিটানোই ভালো।


<h2 id="topic-4">PostgresQL-এ SELECT স্টেটমেন্টের সাথে WHERE ক্লজের উদ্দেশ্য কী?</h2>
<a href="#topics" style="text-decoration: none;">টপিকসমূহ</a>


SQL ল্যাঙ্গুয়েজে যে SELECT স্টেটমেন্ট বা SELECT কীওয়ার্ড, এটা আসলে Projection অপারেশনের কাজ করে। Projection মানে, আউটপুটে কোন কোন কলাম বা ডাটা থাকবে, তা।

অন্যদিকে, RDBMS-এর তত্ত্বে, এক বা একাধিক টেবিল থেকে স্পেসিফিক কিছু রো বা টাপল Selection-এর যে অপারেশন, সে অপারেশন করে SELECT স্টেটমেন্টের WHERE ক্লজ।

এক বা একাধিক টেবিলের অনেক অনেক রো বা টাপল থেকে বিশেষ শর্ত মানে, এমন রো বা টাপল সিলেক্ট করতে বা (Informally Speaking) ফিল্টার করতে আমরা WHERE ক্লজ ব্যবহার করি।

```sql
SELECT * from table_name
WHERE condition;
```

এই condition-এর বৈচিত্র্যই WHERE ক্লজের শক্তি।

সিলেকশনে নিয়ন্ত্রণের স্বার্থে আমরা টেবিলের ডাটার ওপর ব্যাপক ধরণের condition প্রয়োগ করতে পারি। এই ব্যাপকতা ও সূক্ষ্ম নিয়ন্ত্রণ আসে WHERE ক্লজের condition-এ ব্যবহার্য বিভিন্ন রকম অপারেটর থেকে।

1) condition লিখতে আমরা ব্যবহার করতে পারি Arithmetic Comparison Operators। এগুলো নিউমেরিক, টেক্সট ও ডেট-টাইম ডাটার ওপর কাজ করে, এবং এভাবে আমাদেরকে বৈচিত্র্যময় ও সূক্ষ্ম condition লিখার সুযোগ করে দেয়।  >, <, <>, = ইত্যাদি।

2) condition-গুলো কেবল single condition না। Logical Operator (AND, OR, NOT) থাকার কারণে আমরা compound condition লিখতে পারি। ফলে, ডাটা ফিল্টারে আমাদের সূক্ষ্মতা বাড়ে।

3) condition-এর ভেতর আমরা কোনো ডাটার ওপর Set Check-ও করতে পারি। IN ও NOT IN অপারেটর দিয়ে।

4) condition-এর ভেতর আমরা কোনো ডাটার ওপর Range Check-ও করতে পারি। BETWEEN.... AND অপারেটর দিয়ে।

5) condition-এ Text ডাটার ওপর Pattern Matching-ও করতে পারি। LIKE, ILIKE দিয়ে।

6) condition-এ Arithmetic Expression-ও অনুমোদিত। যেমন salary * 2 < 1000।

7) Last, but the least: Subquery-ও লিখা যায় condition-এ!


তো বুঝতেই পারছো যে, WHERE ক্লজের শক্তি কতটা বিচিত্র, ব্যাপক ও সূক্ষ্ম, ডাটা ফিল্টারের জন্য।

<h2 id="topic-5">PostgresQL-এ LIMIT ও OFFSET ক্লজগুলো কেন ব্যবহার করা হয়?</h2>
<a href="#topics" style="text-decoration: none;">টপিকসমূহ</a>



---



এই ছিল আজকের 5টি PostgresQL/RDBMS টপিক। ধন্যবাদ সবাইকে!